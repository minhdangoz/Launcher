/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher3;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.os.SystemClock;
import android.support.v4.view.ViewPager;
import android.support.v4.widget.AutoScrollHelper;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.util.AttributeSet;
import android.util.Log;
import android.util.Pair;
import android.view.ActionMode;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.LinearInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.PopupWindow;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.launcher3.FolderInfo.FolderListener;
import com.android.launcher3.settings.SettingsProvider;
import com.klauncher.biddingos.distribute.data.AppInfoDataManager;
import com.klauncher.biddingos.distribute.model.*;
import com.klauncher.biddingos.impl.AdHelplerImpl;
import com.klauncher.launcher.R;
import com.klauncher.myview.AdApkPagerAdapter;
import com.klauncher.myview.CirclePageIndicator;
import com.klauncher.ping.PingManager;
import com.klauncher.utilities.LogUtil;
import com.squareup.picasso.MemoryPolicy;
import com.squareup.picasso.NetworkPolicy;
import com.squareup.picasso.Picasso;
import com.squareup.picasso.Target;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 * 桌面上的文件夹
 */
@SuppressWarnings("unused")
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener {
    private static final String TAG = "Launcher.Folder";

    private static final String PROTECTED_ACTION = "cyanogenmod.intent.action.PACKAGE_PROTECTED";
    private static final String PROTECTED_STATE =
            "cyanogenmod.intent.action.PACKAGE_PROTECTED_STATE";
    private static final String PROTECTED_COMPONENTS =
            "cyanogenmod.intent.action.PACKAGE_PROTECTED_COMPONENTS";
    private static final String PACKAGE_MIGUAN = "com.miguan.market";
    private static final String PACKAGE_YINGYONGBAO = "com.tencent.android.qqdownloader";
    private static final String PACKAGE_360_ZHUSHOU = "com.qihoo.appstore";
    private static final String PACKAGE_SOUGOU_ZHUSHOU = "com.sogou.androidtool";

    private String[] mPlusPackages = {PACKAGE_MIGUAN, PACKAGE_YINGYONGBAO, PACKAGE_360_ZHUSHOU, PACKAGE_SOUGOU_ZHUSHOU};

    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;
    // 文件夹的四种状态
    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private static final int CLOSE_FOLDER_DELAY_MS = 150;
    //打开时间
    private int mExpandDuration;
    private int mMaterialExpandDuration;
    private int mMaterialExpandStagger;
    private final LayoutInflater mInflater;
    private final IconCache mIconCache;
    private int mState = STATE_NONE;
    // 重新给icon排序动画时间
    private static final int REORDER_ANIMATION_DURATION = 230;
    private static final int REORDER_DELAY = 250;
    // 是否在关闭是重新排列
    private static final int ON_EXIT_CLOSE_DELAY = 400;
    private boolean mRearrangeOnClose = false;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    private int mMaxNumItems;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    //当前拖拽滑动的view
    private View mCurrentDragView;
    //是否外部的拖拽
    private boolean mIsExternalDrag;
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private int[] mEmptyCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    //private int mFolderNameHeight;
    private Rect mTempRect = new Rect();
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;

    //文件夹标题区域
    private int mFolderNameHeight;
    RelativeLayout mFolderTitleSection;
    FolderEditText mFolderName;
    ImageView mFolderLock;
	 
	//应用列表区域
    private ScrollView mScrollView;
    protected CellLayout mContent;
    //APUS 广告控件
    private int mAdApkContainHeight;
    //分页容器
    FrameLayout framelayout_adapks_contain;
    View view_placeholder;
    LinearLayout ll_adapks_contain;
    //标题 刷新 头部
    RelativeLayout relativeAdApkTop;
    ImageView ivAdApkRefesh;
    ViewPager vp_adapk_pager;
    //CirclePageIndicator adapk_indicator;
	
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;
    private boolean mHideLabels;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    private static String sHintText;

    private FocusIndicatorView mFocusIndicatorHandler;

    // We avoid measuring the scroll view with a 0 width or height, as this
    // results in CellLayout being measured as UNSPECIFIED, which it does
    // not support.
    private static final int MIN_CONTENT_DIMEN = 5;

    private boolean mDestroyed;

    private AutoScrollHelper mAutoScrollHelper;

    private Runnable mDeferredAction;
    private boolean mDeferDropAfterUninstall;
    private boolean mUninstallSuccessful;

    private boolean mHiddenFolder = false;
    private BubbleTextView mPlusIcon;
    private static final int PLUS_ICON_ID = -10011001;

    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);

        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);
        mIconCache = app.getIconCache();

        Resources res = getResources();
        //Lenovo-sw zhangyj19 add 2015/07/08 modify folder default row and line
        mMaxCountX = res.getInteger(R.integer.config_folderMaxColumn);
        // Allow scrolling folders when DISABLE_ALL_APPS is true.
        if (LauncherAppState.isDisableAllApps()) {
            //Lenovo-sw zhangyj19 add 2015/07/10 modify folder default max num
            mMaxCountY = Integer.MAX_VALUE;
        } else {
            //Lenovo-sw zhangyj19 add 2015/07/08 modify folder default row and line
            mMaxCountY = res.getInteger(R.integer.config_folderMaxRow);
        }
        //Lenovo-sw zhangyj19 add 2015/07/10 modify folder default max num
        mMaxNumItems = res.getInteger(R.integer.config_folderMaxNum);
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderExpandDuration);
        mMaterialExpandDuration = res.getInteger(R.integer.config_materialFolderExpandDuration);
        mMaterialExpandStagger = res.getInteger(R.integer.config_materialFolderExpandStagger);
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name begin */
        sDefaultFolderName = res.getString(R.string.folder_name);
        sHintText = res.getString(R.string.folder_hint_text);
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name end */
        mLauncher = (Launcher) context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        //在点击的时候获得焦点
        setFocusableInTouchMode(true);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mScrollView = (ScrollView) findViewById(R.id.scroll_view);
        mContent = (CellLayout) findViewById(R.id.folder_content);
        mPlusIcon  = (BubbleTextView) mInflater.inflate(R.layout.folder_application, this, false);
//        Drawable icon = mLauncher.getResources().getDrawable(R.drawable.ic_add_page);
//        icon.setBounds(0, 0, Utilities.sIconTextureWidth, Utilities.sIconTextureHeight);
        Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.folder_add_icon);
        ;
        // Lenovo-sw:yuanyl2, Add edit mode function.
//        iconHeight = b.getHeight();
        LauncherAppState app = LauncherAppState.getInstance();

        FastBitmapDrawable iconDrawable = Utilities.createIconDrawable(b);
        mPlusIcon.setCompoundDrawablePadding((int) getResources().getDimension(R.dimen.folder_plus_icon_padding));
        mPlusIcon.setCompoundDrawables(null, iconDrawable, null, null);
        mPlusIcon.setText(R.string.folder_plus_text);

        /** Lenovo-SW zhaoxin5 20150817 KOLEOSROW-976 END */
        mPlusIcon.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                PackageManager packageManager = mLauncher.getPackageManager();
                Intent intent = null;
                int lenth = mPlusPackages.length;
                for (int i = 0; i < lenth; i++) {
                    intent = packageManager.getLaunchIntentForPackage(mPlusPackages[i]);
                    if (intent != null && intent.getComponent() != null) {
                        try {
                            PingManager.getInstance().reportUserAction4ClickFolderPlus(mPlusPackages[i]);
                            mLauncher.startActivity(intent);
                        } catch (Exception e) {
                            Log.d(TAG, "Folder plus icon can not start exception : " + e.toString());
                        }
                        break;
                    }
                }
            }
        });

//        mPlusIcon.setImageDrawable(icon);
        int measureSpec = MeasureSpec.UNSPECIFIED;

        mFocusIndicatorHandler = new FocusIndicatorView(getContext());
        mContent.addView(mFocusIndicatorHandler, 0);
        mFocusIndicatorHandler.getLayoutParams().height = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
        mFocusIndicatorHandler.getLayoutParams().width = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;

        mContent.setOnClickListener(this);
        mContent.setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                mLauncher.closeFolder();
                return false;
            }
        });
        view_placeholder = (View) findViewById(R.id.view_placeholder);
        view_placeholder.measure(measureSpec, measureSpec);
        view_placeholder.setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                mLauncher.closeFolder();
                return false;
            }
        });
        //LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

        mContent.setCellDimensions(grid.folderCellWidthPx, grid.folderCellHeightPx);
        mContent.setGridSize(0, 0);
        mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        mContent.setInvertIfRtl(true);
        mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
        //Folder Name
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        mFolderName.setOnFocusChangeListener(this);

        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style begin */
        mFolderName.setTextColor(Color.WHITE);
        mFolderName.setHintTextColor(Color.WHITE);
        /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style end */
        mFolderName.measure(measureSpec, measureSpec);
        mFolderNameHeight = mFolderName.getMeasuredHeight();

        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        //mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);

        mHideLabels = SettingsProvider.getBoolean(mLauncher,
                SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS,
                R.bool.preferences_interface_homescreen_hide_icon_labels_default);
        if (mHideLabels) {
            mFolderName.setVisibility(View.GONE);
        }

        mFolderLock = (ImageView) findViewById(R.id.folder_lock);
        mFolderTitleSection = (RelativeLayout) findViewById(R.id.folder_title_section);
        mFolderLock.measure(measureSpec, measureSpec);
        mFolderLock.setOnClickListener(this);
        mFolderTitleSection.measure(measureSpec, measureSpec);
        //APUS
        relativeAdApkTop = (RelativeLayout) findViewById(R.id.relative_apkus_refesh);
        relativeAdApkTop.measure(measureSpec, measureSpec);
        ivAdApkRefesh = (ImageView) findViewById(R.id.imageview_refesh);
        ivAdApkRefesh.setOnClickListener(this);
        framelayout_adapks_contain = (FrameLayout) findViewById(R.id.framelayout_adapks_contain);
        framelayout_adapks_contain.measure(measureSpec, measureSpec);
        ll_adapks_contain = (LinearLayout) findViewById(R.id.ll_adapks_contain);
        ll_adapks_contain.measure(measureSpec, measureSpec);
        mAdApkContainHeight = ll_adapks_contain.getMeasuredHeight();
        //view pager
        vp_adapk_pager = (ViewPager) findViewById(R.id.vp_adapk_pager);
        vp_adapk_pager.measure(measureSpec, measureSpec);
        //PageIndicator
        /*adapk_indicator = (CirclePageIndicator) findViewById(R.id.adapk_indicator);
        adapk_indicator.measure(measureSpec, measureSpec);*/

    }

    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {
        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

    public void onClick(View v) {
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            mLauncher.onClick(v);
        }

        if (v.getId() == R.id.folder_lock) {
            startHiddenFolderManager();
        }
        //广告刷新
        if (v.getId() == R.id.imageview_refesh) {
            ivAdApkRefesh.setRotation(0.0F);
            ivAdApkRefesh.animate().cancel();
            ivAdApkRefesh.animate().rotation(-360.0F).setDuration(600L).setInterpolator(new LinearInterpolator()).start();
            //刷新广告推送应用
            //存在下一页展示下一页  没有下一页请求数据
            if (pageCount > mCurrentFacePage++) {
                vp_adapk_pager.setCurrentItem(mCurrentFacePage);
            } else {
                initAPUS(currentFoldId, true);
                pageCount = 0;
                mCurrentFacePage = 0;
            }
        }

    }

    public void startHiddenFolderManager() {
        Bundle bundle = new Bundle();
        bundle.putBoolean(HiddenFolderFragment.HIDDEN_FOLDER_STATUS, mInfo.hidden);
        mLauncher.validateLockForHiddenFolders(bundle, mFolderIcon);
    }

    public List<Pair<ComponentName, CharSequence>> getComponents() {
        int size = mItemsInReadingOrder.size();
        List<Pair<ComponentName, CharSequence>> components =
                new ArrayList<Pair<ComponentName, CharSequence>>();

        for (int i = 0; i < size; i++) {
            View v = mItemsInReadingOrder.get(i);
            Object tag = v.getTag();
            if (tag instanceof ShortcutInfo) {
                ShortcutInfo shortcut = (ShortcutInfo) tag;
                components.add(Pair.create(shortcut.getIntent().getComponent(), shortcut.title));
            }
        }

        return components;
    }

    public void modifyProtectedApps(boolean protect) {
        ArrayList<ComponentName> components = new ArrayList<ComponentName>();
        for (Pair<ComponentName, CharSequence> item : getComponents()) {
            if (item.first != null) {
                components.add(item.first);
            }
        }

        Intent intent = new Intent();
        intent.setAction(PROTECTED_ACTION);
        intent.putExtra(PROTECTED_STATE, protect);
        intent.putExtra(PROTECTED_COMPONENTS, components);

        mLauncher.sendBroadcast(intent);
    }

    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        //返回是否全局拖动被禁止，如果是，则不执行下面的动作
        if (!mLauncher.isDraggingEnabled()) return true;

        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
			//此处发起拖动处理
            if (mPlusIcon.getParent() != null) {
                mContent.removeView(mPlusIcon);
            }
            mLauncher.getWorkspace().beginDragShared(v, this);

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;

            mContent.removeView(mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
            /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style begin */
            boolean intercept = mLauncher.getWorkspace().isInOverviewMode();
            if((mScrollView != null) && !intercept){
				ll_adapks_contain.setVisibility(View.GONE);
                view_placeholder.setVisibility(View.VISIBLE);
                mScrollView.setBackgroundResource((R.drawable.folder_content_bg));
            } else {
                ll_adapks_contain.setVisibility(View.VISIBLE);
                view_placeholder.setVisibility(View.GONE);
                this.setMeasuredDimension(getContentWidth(), getFolderHeight());
				 mScrollView.setBackground(null);
				 invalidate();
            }
            /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style begin */
        }
        return true;
    }

    //是否正在改名
    public boolean isEditingName() {
        return mIsEditingName;
    }

    //开始为文件夹改名
    public void startEditingFolderName() {
        mFolderName.setHint("");
        mIsEditingName = true;

        mInputMethodManager.showSoftInput(mFolderName, 0);
    }

    //取消文件夹改名框
    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
        mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.       
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name begin */
        String newTitle = mFolderName.getText().toString();
        if(newTitle.trim().equals("") || newTitle.trim().equals(sDefaultFolderName)){
            mInfo.setTitle("");
            mFolderName.setText(sDefaultFolderName);
        }else{
            mInfo.setTitle(newTitle);
        }
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name end */
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public CellLayout getContent() {
        return mContent;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     * 处理触摸事件防止被下面的workspace接收到
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     * 文件夹信息对象
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    //按在Grid里的位置排序
    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    //按阅读顺序排列？从左到右，从上到下。用于从数据库里面读出来的时候放置对象用
    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = mContent.getCountX();
        for (int i = 0; i < count; i++) {
            int x = i % countX;
            int y = i / countX;
            ShortcutInfo item = items.get(i);
            item.cellX = x;
            item.cellY = y;
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        //溢出无效的快捷方式
        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        setupContentForNumItems(children.size());
        placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            /** Lenovo-SW zhaoxin5 20150824 add for XTHREEROW-942 START */
            boolean needRemoveOnLoad = mLauncher.getModel().isShortcutInfosCachedLoaded(child);
            if (needRemoveOnLoad) {
            	overflow.add(child);
            } else if (createAndAddShortcut(child) == null) {
                overflow.add(child);
            } else {
                count++;
            }
            /** Lenovo-SW zhaoxin5 20150824 add for XTHREEROW-942 END */
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item);
            LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        setFolderName();
        updateItemLocationsInDatabase();
    }

    public void setFolderName() {
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name begin */
        if ("".equals(mInfo.title)) {
            mFolderName.setText(sDefaultFolderName);
        } else {
            mFolderName.setText(mInfo.title);
        }
        /*Lenovo-sw zhangyj19 add 2015/09/24 modify Default Folder Name end */
        updateItemLocationsInDatabase();

        // In case any children didn't come across during loading, clean up the folder accordingly
        // Lenovo-sw:yuanyl2, Add edit mode function.
        // Comment these code, because the folder will be empty in XDockView
/*        mFolderIcon.post(new Runnable() {
            public void run() {
                if (getItemCount() <= 1) {
                    replaceFolderWithFinalItem();
                }
            }
        });*/
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);
        mState = STATE_SMALL;
    }

    private void prepareReveal() {
     /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style begin */
        //setScaleX(1f);
        //setScaleY(1f);
        setScaleX(getOverviewModeScale());
        setScaleY(getOverviewModeScale());
        LogUtil.d("prepareReveal",""+getOverviewModeScale());
     /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style  end */
        setAlpha(1f);
        mState = STATE_SMALL;
    }

    public void animateOpen() {
        if (!(getParent() instanceof DragLayer)) return;

        mFolderIcon.checkFolderRingStatus();

        Animator openFolderAnim = null;
        final Runnable onCompleteRunnable;
        // Fix bug with folder animation
        if (false) {
            positionAndSizeAsIcon();
            centerAboutIcon();

            PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
            PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
            PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
            final ObjectAnimator oa =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
            oa.setDuration(mExpandDuration);
            openFolderAnim = oa;

            setLayerType(LAYER_TYPE_HARDWARE, null);
            onCompleteRunnable = new Runnable() {
                @Override
                public void run() {
                    setLayerType(LAYER_TYPE_NONE, null);
                }
            };
        } else {
            prepareReveal();
            // Lenovo-sw zhangyj19 add 2015/06/18 modify folder style
            mLauncher.hideWorkspaceSearchAndHotseat();
            centerAboutIcon();

            int width = getScrollWidth();
            int height = getFolderHeight();
            /*Lenovo-sw zhangyj19 add 2015/07/06 modify PivotX and PivotY begin*/
            /*float transX = - 0.075f * (width / 2 - getPivotX());
            float transY = - 0.075f * (height / 2 - getPivotY());
            setTranslationX(transX);
            setTranslationY(transY);
            PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", transX, 0);
            PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", transY, 0);

            int rx = (int) Math.max(Math.max(width - getPivotX(), 0), getPivotX());
            int ry = (int) Math.max(Math.max(height - getPivotY(), 0), getPivotY());
            float radius = (float) Math.sqrt(rx * rx + ry * ry);
            AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
            Animator reveal = LauncherAnimUtils.createCircularReveal(this, (int) getPivotX(),
                    (int) getPivotY(), 0, radius);
            reveal.setDuration(mMaterialExpandDuration);
            reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
			*/
            PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", 0, 0);
            PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", 0, 0);
            AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
            /*Lenovo-sw zhangyj19 add 2015/07/06 modify PivotX and PivotY end*/
            mContent.setAlpha(0f);
            Animator iconsAlpha = LauncherAnimUtils.ofFloat(mContent, "alpha", 0f, 1f);
            iconsAlpha.setDuration(mMaterialExpandDuration);
            iconsAlpha.setStartDelay(mMaterialExpandStagger);
            iconsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));

            mFolderName.setAlpha(0f);
            /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style begin */
            mFolderName.setTextColor(Color.WHITE);
            mFolderName.setHintTextColor(Color.WHITE);
            /*Lenovo-sw zhangyj19 add 2015/06/18 modify folder style end */
            Animator textAlpha = LauncherAnimUtils.ofFloat(mFolderName, "alpha", 0f, 1f);
            textAlpha.setDuration(mMaterialExpandDuration);
            textAlpha.setStartDelay(mMaterialExpandStagger);
            textAlpha.setInterpolator(new AccelerateInterpolator(1.5f));

            Animator drift = LauncherAnimUtils.ofPropertyValuesHolder(this, tx, ty);
            drift.setDuration(mMaterialExpandDuration);
            drift.setStartDelay(mMaterialExpandStagger);
            drift.setInterpolator(new LogDecelerateInterpolator(60, 0));

            ObjectAnimator animX = ObjectAnimator.ofFloat(this, "scaleX", 0f, 1f);
            ObjectAnimator animY = ObjectAnimator.ofFloat(this, "scaleY", 0f, 1f);
            Resources res = getResources();
            int folderScaleTime = res.getInteger(R.integer.config_folderScaleDuration);
            animX.setDuration(folderScaleTime);
            animY.setDuration(folderScaleTime);
            anim.play(drift);
            anim.play(iconsAlpha);
            anim.play(textAlpha);
            //Lenovo-sw zhangyj19 add 2015/07/06 modify PivotX and PivotY
            //anim.play(reveal);
            //Lenovo-sw zhangyj19 add 2015/07/01 Add folder scale function
            anim.playTogether(animX, animY);

            openFolderAnim = anim;
            /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style begin */
            boolean intercept = mLauncher.getWorkspace().isInOverviewMode();
            if(intercept){
                ll_adapks_contain.setVisibility(View.GONE);
                view_placeholder.setVisibility(View.VISIBLE);
                mScrollView.setLayoutParams(new LinearLayout.LayoutParams(getContentWidth(), getFolderHeight()));
                mScrollView.setBackgroundResource((R.drawable.folder_content_bg));
				//setupContentForNumItems(mInfo.contents.size() + 1);
            } else {
                ll_adapks_contain.setVisibility(View.VISIBLE);
                view_placeholder.setVisibility(View.GONE);
                mScrollView.setLayoutParams(new LinearLayout.LayoutParams(getContentWidth(), getScrollHeight()));
               mScrollView.setBackground(null);
            }
            /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style end */
            mContent.setLayerType(LAYER_TYPE_HARDWARE, null);
            onCompleteRunnable = new Runnable() {
                @Override
                public void run() {
                    mContent.setLayerType(LAYER_TYPE_NONE, null);
                }
            };
        }
        openFolderAnim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        String.format(getContext().getString(R.string.folder_opened),
                        mContent.getCountX(), mContent.getCountY()));
                mState = STATE_ANIMATING;
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;

                if (onCompleteRunnable != null) {
                    onCompleteRunnable.run();
                }

                setFocusOnFirstChild();
            }
        });
        openFolderAnim.start();

        // Make sure the folder picks up the last drag move even if the finger doesn't move.
        if (mDragController.isDragging()) {
            mDragController.forceTouchMove();
        } else {//添加加号
            addPlusIconlast();
        }
    }

    public void beginExternalDrag(ShortcutInfo item) {
        setupContentForNumItems(getItemCount() + 1);
        findAndSetEmptyCells(item);

        mCurrentDragInfo = item;
        mEmptyCell[0] = item.cellX;
        mEmptyCell[1] = item.cellY;
        mIsExternalDrag = true;

        mDragInProgress = true;
    }

    private void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    private void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    /** Lenovo-SW zhaoxin5 20150812 从文件夹中启动应用关闭退出文件夹的动画 START */
    public void closeWithoutAnimate() {
    	onCloseComplete();
    	mLauncher.showWorkspaceSearchAndHotseat();
    }
    /** Lenovo-SW zhaoxin5 20150812 从文件夹中启动应用关闭退出文件夹的动画 END */
    
    public void animateClosed() {
        if (!(getParent() instanceof DragLayer)) return;
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.9f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.9f);
        final ObjectAnimator oa =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                onCloseComplete();
                setLayerType(LAYER_TYPE_NONE, null);
                mState = STATE_SMALL;
            }
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        getContext().getString(R.string.folder_closed));
                mState = STATE_ANIMATING;
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        oa.start();
     // Lenovo-sw zhangyj19 add 2015/06/18 modify folder style
        mLauncher.showWorkspaceSearchAndHotseat();
    }

    public boolean acceptDrop(DragObject d) {
        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        if (d.dragSource instanceof XDockView) {
            if (isFull()) {
                XDockView dock = (XDockView) d.dragSource;
                dock.showOutOfFolderMessage();
                return false;
            }
        } else if(isFull()) {
            Toast.makeText(getContext(), R.string.folder_out_of_space, Toast.LENGTH_SHORT).show();
            return false;
        }

        return (d.dragInfo instanceof LayoutInfo
                || itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION
                || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
    }

    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
        int[] emptyCell = new int[2];
        if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
            item.cellX = emptyCell[0];
            item.cellY = emptyCell[1];
            return true;
        } else {
            return false;
        }
    }

    //向Folder添加ShortcutInfo
    protected View createAndAddShortcut(ShortcutInfo item) {
        final BubbleTextView textView =
            (BubbleTextView) mInflater.inflate(R.layout.folder_application, this, false);
        textView.applyFromShortcutInfo(item, mIconCache, false);

        textView.setOnClickListener(this);
        textView.setOnLongClickListener(this);
        textView.setOnFocusChangeListener(mFocusIndicatorHandler);

        if (mHideLabels) {
            textView.setTextVisibility(!mHideLabels);
        }

        // We need to check here to verify that the given item's location isn't already occupied
        // by another item.
        if (mContent.getChildAt(item.cellX, item.cellY) != null || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mContent.getCountX() || item.cellY >= mContent.getCountY()) {
            // This shouldn't happen, log it.
            Log.e(TAG, "Folder order not properly persisted during bind");
            if (!findAndSetEmptyCells(item)) {
                return null;
            }
        }

        CellLayout.LayoutParams lp =
            new CellLayout.LayoutParams(item.cellX, item.cellY, item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int)item.id, lp, true);
        Log.d(TAG, "Folder addViewToCellLayout ");
        return textView;
    }

    private void addPlusIconlast(){
        boolean isExist = isPlusIconPackageExist();
        if (!isExist || mPlusIcon.getParent() != null ) {
            return;
        }
        ShortcutInfo info = new ShortcutInfo();
        info.spanX = 1;
        info.spanY = 1;
        if (!findAndSetEmptyCells(info)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(info);
        }
        if (mContent.getChildAt(info.cellX, info.cellY) != null || info.cellX < 0 || info.cellY < 0
                || info.cellX >= mContent.getCountX() || info.cellY >= mContent.getCountY()) {
            // This shouldn't happen, log it.
            Log.e(TAG, "Folder order not properly persisted during bind");
            if (!findAndSetEmptyCells(info)) {
                return;
            }
        }
        CellLayout.LayoutParams lp =
                new CellLayout.LayoutParams(info.cellX, info.cellY, 1, 1);
        mContent.addViewToCellLayout(mPlusIcon, -1, PLUS_ICON_ID, lp, true);
    }

    private boolean isPlusIconPackageExist(){
        boolean isExist = false;
        PackageManager packageManager = mLauncher.getPackageManager();
        Intent intent = null;
        int lenth = mPlusPackages.length;
        for (int i = 0; i < lenth; i++) {
            intent = packageManager.getLaunchIntentForPackage(mPlusPackages[i]);
            if (intent != null && intent.getComponent() != null) {
                isExist = true;
                break;
            }
        }
        return isExist;
    }

    public void onDragEnter(DragObject d) {
        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            realTimeReorder(mEmptyCell, mTargetCell);
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;
            startY = wrap ? empty[1] + 1 : empty[1];
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }
    //解决 向下 scrollView不能滑动问题
    int oldDragOverY = -1;
    boolean oldDirectUp = false;
    public void onDragOver(DragObject d) {
        final DragView dragView = d.dragView;
        final int scrollOffset = mScrollView.getScrollY();

        // Lenovo-sw:yuanyl2, Add edit mode function.
        // final float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, dragView, null);
        float[] r = new float[2];
        if (isDragLayout(d)) {
            r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
                    d.dragViewList.get(0), r);
        } else {
            r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
                    d.dragView, r);
        }

        r[0] -= getPaddingLeft();
        r[1] -= getPaddingTop();

        final long downTime = SystemClock.uptimeMillis();
        //向下滑动
        if (d.y - oldDragOverY > 0) {
            final MotionEvent translatedEv = MotionEvent.obtain(
                    downTime, downTime, MotionEvent.ACTION_MOVE, 0, d.y + mAdApkContainHeight, 0);

            if (!mAutoScrollHelper.isEnabled()) {
                mAutoScrollHelper.setEnabled(true);
            }

            final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
            translatedEv.recycle();

            if (handled) {
                mReorderAlarm.cancelAlarm();
            } else {
                mTargetCell = mContent.findNearestArea(
                        (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
                if (isLayoutRtl()) {
                    mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
                }
                if (mTargetCell[0] != mPreviousTargetCell[0]
                        || mTargetCell[1] != mPreviousTargetCell[1]) {
                    mReorderAlarm.cancelAlarm();
                    mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                    mReorderAlarm.setAlarm(REORDER_DELAY);
                    mPreviousTargetCell[0] = mTargetCell[0];
                    mPreviousTargetCell[1] = mTargetCell[1];
                }
            }
            oldDragOverY = d.y;
            oldDirectUp = false;
        } else if (d.y - oldDragOverY < 0) {//向上滑动
            final MotionEvent translatedEv = MotionEvent.obtain(
                    downTime, downTime, MotionEvent.ACTION_MOVE, 0, d.y - 20, 0);

            if (!mAutoScrollHelper.isEnabled()) {
                mAutoScrollHelper.setEnabled(true);
            }

            final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
            translatedEv.recycle();

            if (handled) {
                mReorderAlarm.cancelAlarm();
            } else {
                mTargetCell = mContent.findNearestArea(
                        (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
                if (isLayoutRtl()) {
                    mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
                }
                if (mTargetCell[0] != mPreviousTargetCell[0]
                        || mTargetCell[1] != mPreviousTargetCell[1]) {
                    mReorderAlarm.cancelAlarm();
                    mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                    mReorderAlarm.setAlarm(REORDER_DELAY);
                    mPreviousTargetCell[0] = mTargetCell[0];
                    mPreviousTargetCell[1] = mTargetCell[1];
                }
            }
            oldDragOverY = d.y;
            oldDirectUp = true;
        } else {//划出文件夹
            if (oldDirectUp) {
                final MotionEvent translatedEv = MotionEvent.obtain(
                        downTime, downTime, MotionEvent.ACTION_MOVE,0, d.y - 20, 0);

                if (!mAutoScrollHelper.isEnabled()) {
                    mAutoScrollHelper.setEnabled(true);
                }

                final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
                translatedEv.recycle();

                if (handled) {
                    mReorderAlarm.cancelAlarm();
                } else {
                    mTargetCell = mContent.findNearestArea(
                            (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
                    if (isLayoutRtl()) {
                        mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
                    }
                    if (mTargetCell[0] != mPreviousTargetCell[0]
                            || mTargetCell[1] != mPreviousTargetCell[1]) {
                        mReorderAlarm.cancelAlarm();
                        mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                        mReorderAlarm.setAlarm(REORDER_DELAY);
                        mPreviousTargetCell[0] = mTargetCell[0];
                        mPreviousTargetCell[1] = mTargetCell[1];
                    }
                }
                oldDragOverY = d.y;
            } else {
                final MotionEvent translatedEv = MotionEvent.obtain(
                        downTime, downTime, MotionEvent.ACTION_MOVE, 0, d.y + mAdApkContainHeight, 0);

                if (!mAutoScrollHelper.isEnabled()) {
                    mAutoScrollHelper.setEnabled(true);
                }

                final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
                translatedEv.recycle();

                if (handled) {
                    mReorderAlarm.cancelAlarm();
                } else {
                    mTargetCell = mContent.findNearestArea(
                            (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
                    if (isLayoutRtl()) {
                        mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
                    }
                    if (mTargetCell[0] != mPreviousTargetCell[0]
                            || mTargetCell[1] != mPreviousTargetCell[1]) {
                        mReorderAlarm.cancelAlarm();
                        mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                        mReorderAlarm.setAlarm(REORDER_DELAY);
                        mPreviousTargetCell[0] = mTargetCell[0];
                        mPreviousTargetCell[1] = mTargetCell[1];
                    }
                }
                oldDragOverY = d.y;
            }
        }

    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    //// 获得被拖动view的视觉中心点。用来表示view的位置以及放下的时候用这个点判断位置要放到哪个位置
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        /** Lenovo-SW zhaoxin5 20150710 add for LANCHROW-231 START */
    	if(mLauncher.isDockViewShowing()) return;
        /** Lenovo-SW zhaoxin5 20150710 add for LANCHROW-231 END */
        mLauncher.closeFolder();
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
        mIsExternalDrag = false;
    }

    /** Lenovo-SW zhaoxin5 20150710 add for LANCHROW-231 START */
    public void animateFromLastToFirst() {
    	mReorderAlarm.cancelAlarm();
        mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
        mReorderAlarm.setAlarm(REORDER_DELAY);
        mPreviousTargetCell[0] = mTargetCell[0] = mContent.getCountX() - 1;
        mPreviousTargetCell[1] = mTargetCell[1] = mContent.getCountY() - 1;
    }
    /** Lenovo-SW zhaoxin5 20150710 add for LANCHROW-231 END */
    
    public void onDragExit(DragObject d) {
        // Exiting folder; stop the auto scroller.
        mAutoScrollHelper.setEnabled(false);
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        mReorderAlarm.cancelAlarm();
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean isFlingToDelete, final boolean success) {

        if (mDeferDropAfterUninstall) {
            Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
            mDeferredAction = new Runnable() {
                    public void run() {
                        onDropCompleted(target, d, isFlingToDelete, success);
                        mDeferredAction = null;
                    }
                };
            return;
        }

        boolean beingCalledAfterUninstall = mDeferredAction != null;
        boolean successfulDrop =
                success && (!beingCalledAfterUninstall || mUninstallSuccessful);

        if (successfulDrop) {
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && target != this) {
                replaceFolderWithFinalItem();
            }
        } else {
            setupContentForNumItems(getItemCount());
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if (!successfulDrop) {
                    mSuppressFolderDeletion = true;
                }
                completeDragExit();
            }
        } else {//滑动结束 添加加号
            addPlusIconlast();
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style begin */
        boolean intercept = mLauncher.getWorkspace().isInOverviewMode();
        if((mScrollView != null) && !intercept){
            ll_adapks_contain.setVisibility(View.VISIBLE);
            view_placeholder.setVisibility(View.GONE);
            mScrollView.setLayoutParams(new LinearLayout.LayoutParams(getContentWidth(), getScrollHeight()));
            mScrollView.setBackground(null);
        } else {
            ll_adapks_contain.setVisibility(View.GONE);
            view_placeholder.setVisibility(View.VISIBLE);
            mScrollView.setLayoutParams(new LinearLayout.LayoutParams(getContentWidth(), getFolderHeight()));
            mScrollView.setBackgroundResource((R.drawable.folder_content_bg));
			//setupContentForNumItems(mInfo.contents.size() + 1);
        }
        /*Lenovo-sw zhangyj19 add 2015/07/09 modify folder frame style end */
        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();

        XDockView dockView = mLauncher.getDockView();
        if (dockView.isDragFromWorkSpace) {
            dockView.updateSelectCount();
            dockView.dragDeleteIsCompleted = true;
            dockView.isDragFromWorkSpace = false;
        }
    }

    public void deferCompleteDropAfterUninstallActivity() {
        mDeferDropAfterUninstall = true;
    }

    public void onUninstallActivityReturned(boolean success) {
        mDeferDropAfterUninstall = false;
        mUninstallSuccessful = success;
        if (mDeferredAction != null) {
            mDeferredAction.run();
        }
    }

    @Override
    public float getIntrinsicIconScaleFactor() {
        return 1f;
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    @Override
    public boolean supportsAppInfoDropTarget() {
    	// Lenovo-SW zhaoxin5 20150810 show InfoDropTarget instead of QuickShareDropTarget
        return true;
    }

    @Override
    public boolean supportsDeleteDropTarget() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            if (info != null) {
                LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            }
        }
    }

    private void updateItemLocationsInDatabaseBatch() {
        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            items.add(info);
        }

        LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
    }

    public void addItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
                    info.cellX, info.cellY, false);
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    //设置显示内容面板CellLayout的大小
    private void setupContentDimensions(int count) {
        ArrayList<View> list = getItemsInReadingOrder();

        int countY = 0;
        int countYMode = 0;
        /*
        int countX = mContent.getCountX();
        int countY = mContent.getCountY();
        boolean done = false;

        while (!done) {
            int oldCountX = countX;
            int oldCountY = countY;
            if (countX * countY < count) {
                // Current grid is too small, expand it
                if ((countX <= countY || countY == mMaxCountY) && countX < mMaxCountX) {
                    countX++;
                } else if (countY < mMaxCountY) {
                    countY++;
                }
                if (countY == 0) countY++;
            } else if ((countY - 1) * countX >= count && countY >= countX) {
                countY = Math.max(0, countY - 1);
            } else if ((countX - 1) * countY >= count) {
                countX = Math.max(0, countX - 1);
            }
            done = countX == oldCountX && countY == oldCountY;
        }
        */
        countY = count/mMaxCountX;
        countYMode = count%mMaxCountX;
        if (countYMode > 0) {
            countY = countY + 1;
        } else {//countY +1  加号多一行
            if (isPlusIconPackageExist()) {
                countY = countY + 1;
            }
        }
        mContent.setGridSize(mMaxCountX, countY);
        arrangeChildren(list);
    }

    public boolean isFull() {
        return getItemCount() >= mMaxNumItems;
    }

    public int getMaxItems() {
        return mMaxNumItems;
    }

    //以图标为中心，中心对齐，比如缩放时要以中心对齐
    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        int width = getScrollWidth();
        int height = getFolderHeight();


        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();


        int currentPage = mLauncher.getWorkspace().getNextPage();
        // In case the workspace is scrolling, we need to use the final scroll to compute
        // the folders bounds.
        // 如果workspace正在滚动，就强制滚动到最后以计算最终的位置
        mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
        // We first fetch the currently visible CellLayoutChildren
        // 首先获取可见CellLayoutChildren
        CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
        /* Lenovo-sw luyy1 add start to fix XTHREEROW-817 2015-09-02*/
        if (null == currentLayout) {
            return;
        }
        /* Lenovo-sw luyy1 add end to fix XTHREEROW-817 2015-09-02*/
        ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
        Rect bounds = new Rect();
        parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
        // We reset the workspaces scroll
        // 强制重置workspace的滚动状态
        mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);

        // We need to bound the folder to the currently visible CellLayoutChildren
        // 重新调整folder的边界，如果有需要的话，比如实际内容比folder要更大或者更小
        int left = Math.min(bounds.left,
                bounds.left + bounds.width() - width);
        int top = bounds.top + bounds.height()/2 - mFolderNameHeight - getScrollHeight()/2;
        if (grid.isPhone() && (grid.availableWidthPx - width) < grid.iconSizePx) {
            // Center the folder if it is full (on phones only)
            left = (grid.availableWidthPx - width) / 2;
        } else if (width >= bounds.width()) {// 如果实际内容比folder要更大或者更小，那么调整为实际大小
            // If the folder doesn't fit within the bounds, center it about the desired bounds
            left = bounds.left + (bounds.width() - width) / 2;
        }
        /*Lenovo-sw zhangyj19 add 2015/07/06 modify PivotX and PivotY begin*/
        //int folderPivotX = width / 2 ;
        //int folderPivotY = height / 2;
        int folderDragLayerX = mLauncher.getLocationInDragLayer(mFolderIcon)[0];
        int folderDragLayerY = mLauncher.getLocationInDragLayer(mFolderIcon)[1];
        int folderPivotX = folderDragLayerX - left + mFolderIcon.getMeasuredWidth()/2;
        int folderPivotY = folderDragLayerY - top + mFolderIcon.getMeasuredHeight()/2;
        /*Lenovo-sw zhangyj19 add 2015/07/06 modify PivotX and PivotY end*/
        // 设置Folder的锚点
        setPivotX(folderPivotX);
        setPivotY(folderPivotY);
        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
                (1.0f * folderPivotX / width));
        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
                (1.0f * folderPivotY / height));

        lp.width = width;
        lp.height = height;
        lp.x = left;
        lp.y = top;
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    //根据item数量设置显示面板CellLayout的大小和位置
    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon();
    }


    private int getContentAreaWidth() {
        return Math.max(mContent.getDesiredWidth(), MIN_CONTENT_DIMEN);
    }
    /*Lenovo-sw zhangyj19 add 2015/06/11 modify folder style begin */
    private int getFolderHeight() {
        int height = getPaddingTop() + getPaddingBottom() + mFolderNameHeight + mAdApkContainHeight
                + getScrollHeight();
        return height;

    }

    private int getFolderWidth() {
        int width = getPaddingLeft() + getPaddingRight() + getScrollWidth();
        return width;
    }
    private int getScrollHeight() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        Resources res = getResources();
        //Lenovo-sw zhangyj19 add 2015/07/08 modify folder default row and line
        LogUtil.d("config_folderMaxRow","config_folderMaxRow = "+res.getInteger(R.integer.config_folderMaxRow));
        int scrollHeight =  (int) (getPaddingTop() + getPaddingBottom() +
                (res.getInteger(R.integer.config_folderMaxRow) * mContent.getCellHeight()) +
                (3 * mContent.getHeightGap())) ;
        //与屏幕高度比较
        WindowManager wm = (WindowManager) mLauncher.getSystemService(Context.WINDOW_SERVICE);
        int width = wm.getDefaultDisplay().getWidth();//屏幕宽度
        int height = wm.getDefaultDisplay().getHeight();
        LogUtil.d("getScrollHeight","screenHeight = "+height);
        LogUtil.d("getScrollHeight","folderheight ="+(getPaddingTop() + getPaddingBottom() + mFolderNameHeight + scrollHeight + mAdApkContainHeight));
        if(getPaddingTop() + getPaddingBottom() + mFolderNameHeight + scrollHeight + mAdApkContainHeight >= (int)(height*0.8)){
            scrollHeight =  (int) (getPaddingTop() + getPaddingBottom() +
                    (3 * mContent.getCellHeight()) +
                    (2 * mContent.getHeightGap())) ;
        }

        boolean intercept = mLauncher.getWorkspace().isInOverviewMode();
        int folderScale = res.getInteger(R.integer.folder_height_scale);
        LogUtil.d("folderScale","folderScale = "+folderScale);
        int mFolderPaddingTop = res.getDimensionPixelSize(R.dimen.folder_preview_padding);
        if(intercept){
            return scrollHeight + mFolderPaddingTop;
        } else {
            return Math.min(scrollHeight, mContent.getDesiredHeight()) + mFolderPaddingTop;
        }
    }
    private int getScrollWidth() {
        CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);
        int maxFolderWidth = 0;
        if(cellLayout != null){
            maxFolderWidth = cellLayout.getWidth();
        }
        return maxFolderWidth;
    }

    private int getContentWidth() {
        Resources res = getResources();
        //Lenovo-sw zhangyj19 add 2015/07/08 modify folder default row and line
        int scrollWidth = getPaddingLeft() + getPaddingRight() +
                (res.getInteger(R.integer.config_folderMaxColumn) * mContent.getCellWidth()) +
                (2 * mContent.getWidthGap());
        return scrollWidth;
    }
    private int getBannerWidth(){
        int iconSize = LauncherAppState.getInstance().getDynamicGrid().getDeviceProfile().iconSizePx;
        int bannerWidth  = (int) (1.5 * iconSize)*3;
        return bannerWidth;
    }

    private float getOverviewModeScale() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        boolean intercept = mLauncher.getWorkspace().isInOverviewMode();
        if(intercept){
            return grid.getOverviewModeScale();
        } else {
            return 1.0f;
        }
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

        //int scrollWidth = getScrollWidth();
		int scrollWidth = getContentWidth();
        int scrollHeight = getScrollHeight();

        int widthSpec = MeasureSpec.makeMeasureSpec(scrollWidth,
                MeasureSpec.EXACTLY);
        int heightSpec = MeasureSpec.makeMeasureSpec(scrollHeight,
                MeasureSpec.EXACTLY);

        mContent.setFixedSize(getContentWidth(), mContent.getDesiredHeight());

        //mScrollView.measure(widthSpec, heightSpec);
        mFolderName.measure(widthSpec, MeasureSpec.makeMeasureSpec(
                mFolderNameHeight, MeasureSpec.EXACTLY));
        mFolderLock.measure(widthSpec, MeasureSpec.makeMeasureSpec(
                mFolderNameHeight, MeasureSpec.EXACTLY));
        mFolderTitleSection.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
        framelayout_adapks_contain.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(mAdApkContainHeight, MeasureSpec.EXACTLY));
        view_placeholder.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(mAdApkContainHeight, MeasureSpec.EXACTLY));
        ll_adapks_contain.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(mAdApkContainHeight, MeasureSpec.EXACTLY));

        WindowManager wm = (WindowManager) mLauncher.getSystemService(Context.WINDOW_SERVICE);
        mScrollView.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(scrollHeight, MeasureSpec.EXACTLY));
        mContent.measure(widthSpec, MeasureSpec
                .makeMeasureSpec(scrollHeight, MeasureSpec.EXACTLY));
        //setMeasuredDimension(getScrollWidth(), getFolderHeight());
		setMeasuredDimension(getContentWidth(), getFolderHeight());
    }
    /*Lenovo-sw zhangyj19 add 2015/06/11 modify folder style end */
    //重置item们的位置
    private void arrangeChildren(ArrayList<View> list) {
        int[] vacant = new int[2];
        if (list == null) {
            list = getItemsInReadingOrder();
        }
        mContent.removeAllViews();

        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            mContent.getVacantCell(vacant, 1, 1);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            }
            boolean insert = false;
            mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        mItemsInvalidated = true;
    }

    public int getItemCount() {
        return mContent.getShortcutsAndWidgets().getChildCount();
    }

    public View getItemAt(int index) {
        return mContent.getShortcutsAndWidgets().getChildAt(index);
    }

    //文件夹关闭动画完成后的处理动作
    private void onCloseComplete() {
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
		//关闭文件夹后移除加号 防止缩略图有加号
        if (mPlusIcon.getParent() != null) {
            mContent.removeView(mPlusIcon);
        }
        mDragController.removeDropTarget((DropTarget) this);
        clearFocus();
        mFolderIcon.requestFocus();

        if (mRearrangeOnClose) {
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
        }
        if (getItemCount() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    public void removeEmptyFolderFromWorkspace() {
    	Runnable onCompleteRunnable = new Runnable() {
    		@Override
            public void run() {
		        CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);
		    	if (getItemCount() < 1) {
		            LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
		            if (cellLayout != null) {
		                cellLayout.removeView(mFolderIcon);
		            }
		            if (mFolderIcon instanceof DropTarget) {
		                mDragController.removeDropTarget((DropTarget) mFolderIcon);
		            }
		            mLauncher.removeFolder(mInfo);
		        }
    		}
    	};
    	mLauncher.runOnUiThread(onCompleteRunnable);
    }

    //用最后一个剩余的item代替当前folder显示在桌面上，这发生在Folder里面只有一个item的时候
    private void replaceFolderWithFinalItem() {
        if (mInfo.hidden && getItemCount() >= 1) {
            return;
        }
    	if(mLauncher.getWorkspace().isInOverviewMode()) {
    		return;
    	}
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);

                View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                // 将最后一个item从Folder移动到桌面上，与Folder一个位置。
                // 但是在这个if块里面并没有实际移动，而仅仅是生成数据并放到了数据库中。
                if (getItemCount() == 1) {
                    ShortcutInfo finalItem = mInfo.contents.get(0);
                    child = mLauncher.createShortcut(R.layout.application, cellLayout,
                            finalItem);
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                            mInfo.screenId, mInfo.cellX, mInfo.cellY);
                }
                if (getItemCount() <= 1) {
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    if (cellLayout != null) {
                        // b/12446428 -- sometimes the cell layout has already gone away?
                        cellLayout.removeView(mFolderIcon);
                    }
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()
                // to ensure that hotseat items are placed correctly.
                // 在删除文件夹后才添加最后一个item到桌面，这是为了防止在同一时间同一位置有两个item
                if (child != null) {
                    mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container, mInfo.screenId,
                            mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                }
            }
        };
        View finalChild = getItemAt(0);
        if (finalChild != null) {
            //文件夹销毁动画
            mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        } else {
            mLauncher.runOnUiThread(onCompleteRunnable);
        }
        mDestroyed = true;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    // 按方向键时让最后一个Child获得焦点？
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    public void onDrop(DragObject d) {
        Runnable cleanUpRunnable = null;

        // Lenovo-sw:yuanyl2, Add edit mode function. Begin.
        if (d.dragInfo instanceof LayoutInfo) {
            XDockView dockview = mLauncher.getDockView();
            LayoutInfo layoutInfo = (LayoutInfo) d.dragInfo;
            Rect r = new Rect();
            final ArrayList<DragView> mSourceItem = new ArrayList<DragView>();
            final ArrayList<ShortcutInfo> mSourceInfo = new ArrayList<ShortcutInfo>();
            final ArrayList<View> mTargetItem = new ArrayList<View>();
            final ArrayList<DragView> mBackItem = new ArrayList<DragView>();
            final ArrayList<ShortcutInfo> mBackInfo = new ArrayList<ShortcutInfo>();

            for (int i = 0; i < layoutInfo.getCount(); i++) {
                ShortcutInfo i_info = (ShortcutInfo) layoutInfo.getInfoAt(i);
                DragView view = d.dragViewList.get(i);
                if (i == 0) {
                    mLauncher.getDragLayer().getViewRectRelativeToSelf(view, r);
                }

                View targetView = dockview.dropToCurrentScreen(view, i_info, null);
                if (targetView != null) {
                    targetView.setVisibility(View.INVISIBLE);
                    mSourceItem.add(view);
                    mSourceInfo.add(i_info);
                    mTargetItem.add(targetView);
                } else {
                    mBackItem.add(view);
                    mBackInfo.add(i_info);
                }
            }

            for (int i = 0; i < mSourceItem.size(); i++) {
                dockview.animDropToCurrentScreen(mSourceItem.get(i),
                        mTargetItem.get(i), r);
                dockview.removeDockItemByInfo(mSourceInfo.get(i), true);
            }
            for (int i = 0; i < mBackItem.size(); i++) {
                dockview.setBackByDrag();
                dockview.animDragviewIntoPosition(mBackItem.get(i),
                        mBackInfo.get(i), r);
            }
            dockview.hide();
            dockview.startAnimatorSet(true, false);
            return;
        }
        // Lenovo-sw:yuanyl2, Add edit mode function. End.

        // If we are coming from All Apps space, we defer removing the extra empty screen
        // until the folder closes
        if (d.dragSource != mLauncher.getWorkspace() && !(d.dragSource instanceof Folder)) {
            cleanUpRunnable = new Runnable() {
                @Override
                public void run() {
                    mLauncher.exitSpringLoadedDragModeDelayed(true,
                            Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
                            null);
                }
            };
        }

        View currentDragView;
        ShortcutInfo si = mCurrentDragInfo;
        if (mIsExternalDrag) {
            si.cellX = mEmptyCell[0];
            si.cellY = mEmptyCell[1];

            // Actually move the item in the database if it was an external drag. Call this
            // before creating the view, so that ShortcutInfo is updated appropriately.
            LauncherModel.addOrMoveItemInDatabase(
                    mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);

            // We only need to update the locations if it doesn't get handled in #onDropCompleted.
            if (d.dragSource != this) {
                updateItemLocationsInDatabaseBatch();
            }
            mIsExternalDrag = false;

            currentDragView = createAndAddShortcut(si);
        } else {
            currentDragView = mCurrentDragView;
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) currentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellX = lp.cellY = mEmptyCell[1];
            mContent.addViewToCellLayout(currentDragView, -1, (int) si.id, lp, true);
        }

        if (d.dragView.hasDrawn()) {

            // Temporarily reset the scale such that the animation target gets calculated correctly.
            float scaleX = getScaleX();
            float scaleY = getScaleY();
            setScaleX(1.0f);
            setScaleY(1.0f);
            mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView,
                    cleanUpRunnable, null);
            setScaleX(scaleX);
            setScaleY(scaleY);
        } else {
            d.deferDragViewCleanupPostAnimation = false;
            currentDragView.setVisibility(VISIBLE);
        }
        mItemsInvalidated = true;
        setupContentDimensions(getItemCount());

        // Temporarily suppress the listener, as we did all the work already here.
        mSuppressOnAdd = true;
        mInfo.add(si);
        mSuppressOnAdd = false;
        // Clear the drag info, as it is no longer being dragged.
        mCurrentDragInfo = null;
        addPlusIconlast();//滑动添加add 
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);

        if (v != null) {
            v.setVisibility(INVISIBLE);
        }
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if (v != null) {
            v.setVisibility(VISIBLE);
        }

    }

    public void onAdd(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        if (!findAndSetEmptyCells(item)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(item);
        }
        createAndAddShortcut(item);
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
    }

    public void onRemove(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        View v = getViewForInfo(item);
        mContent.removeView(v);
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        if (getItemCount() <= 1) {
            replaceFolderWithFinalItem();
        }
    }

    public View getViewForInfo(ShortcutInfo item) {
        for (int j = 0; j < mContent.getCountY(); j++) {
            for (int i = 0; i < mContent.getCountX(); i++) {
                View v = mContent.getChildAt(i, j);
                if (v!=null && v.getTag() == item) {
                    return v;
                }
            }
        }
        return null;
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    @Override
    public void onRemoveAll() {
    }

    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = mContent.getChildAt(i, j);
                    if (v != null) {
                        if (PLUS_ICON_ID == v.getId()) {
                        } else {
                            mItemsInReadingOrder.add(v);
                        }

                    }
                }
            }
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public ShortcutInfo getShortcutForComponent(ComponentName componentName) {
        for (View v : mItemsInReadingOrder) {
            Object tag = v.getTag();
            if (tag instanceof ShortcutInfo) {
                ComponentName cName = ((ShortcutInfo) tag).getIntent().getComponent();
                if (cName.equals(componentName)) {
                    return (ShortcutInfo) tag;
                }
            }
        }

        return null;
    }

    public ShortcutInfo getShortcutForPosition(int position) {
        if (position < 0 || position >= mItemsInReadingOrder.size()) {
            return null;
        }
        View v = mItemsInReadingOrder.get(position);
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            return (ShortcutInfo) tag;
        }
        return null;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
        }
    }

    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        getHitRect(outRect);
		//文件夹滑动区域
        outRect.bottom = outRect.bottom - mAdApkContainHeight;
        //top  加上 文件夹标题
        outRect.top = outRect.top + mFolderNameHeight;
    }

    public View getViewFromPosition(int position) {
        return mItemsInReadingOrder.get(position);
    }

    public void scrollToBottom() {
        mScrollView.post(new Runnable() {
            public void run() {
                mScrollView.scrollTo(0, mScrollView.getBottom());
            }
        });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
	// Lenovo-sw:yuanyl2, Add edit mode function. Begin.
    private boolean isDragLayout(DragObject d) {
        return (d.dragViewList != null && d.dragViewList.size() != 0);
    }

    protected void removeRecord() {
        ViewGroup parent = (ViewGroup) getParent();
		if (parent != null) {
			parent.removeView(this);
		}
	}
	
    public void deleteFolderFormDockView() {
        final int childcount = mInfo.contents.size();

        if (childcount > 0) {
            Log.d(TAG, "[Folder] deleteFolderFormDockView: childCount > 0 so return");
            return;
        }
        LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
        mDestroyed = true;
        removeRecord();
    }

    public void cancelExitFolder() {
//        if (mLauncher.getHandler().hasMessages(MSG_CLOSE_FOLDER)) {
//            mLauncher.getHandler().removeMessages(MSG_CLOSE_FOLDER);
//        }
//        if (mOnExitAlarm.alarmPending()) {
//            mOnExitAlarm.cancelAlarm();
//        }
//        super.cancelExitFolder();
    }

    public int getMaxCountY() {
        return getResources().getInteger(R.integer.config_folderMaxRow);
    }
    // Lenovo-sw:yuanyl2, Add edit mode function. End.
    private ConnectivityManager mConnectivityManager;
    private NetworkInfo netInfo;
    //当前广告id
    private static String currentFoldId = AppInfoDataManager.AD_PLACEMENT_MODULE_MO_REN;
    List<com.klauncher.biddingos.distribute.model.AppInfo> appInfoList = new ArrayList<com.klauncher.biddingos.distribute.model.AppInfo>();
    /**
     * 初始化 pingxiaotong 请求 显示 广告应用
     */
    public void initAPUS(String foldid, boolean isfresh) {
        //刷新不隐藏
        if(isfresh) {
            ll_adapks_contain.setVisibility(View.GONE);
            relativeAdApkTop.setVisibility(View.INVISIBLE);
            vp_adapk_pager.setVisibility(View.INVISIBLE);
            view_placeholder.setVisibility(View.VISIBLE);
        }

        mConnectivityManager = (ConnectivityManager) mLauncher.getSystemService(Context.CONNECTIVITY_SERVICE);
        netInfo = mConnectivityManager.getActiveNetworkInfo();
        if (netInfo != null && netInfo.isAvailable()) {
            currentFoldId = foldid;
            //清楚上次缓存  解决 已经安装 推广中还有这个应用的bug
            clearCacheData();
            //先用缓存数据
            //appInfoList.addAll(AdHelper.getCacheAppInfo(foldid));
            //setAndrefushApkItems(appInfoList);
            /*//demo 测试 begin
            com.klauncher.biddingos.distribute.model.AppInfo appInfo = new AppInfo();
            appInfo.setApp_id("0001");
            appInfo.setApp_download_url("http://wap.apk.anzhi.com/data3/apk/201509/25/59b889fe34ff222aa82ebc7ab582aeac_33177100.apk");
            appInfo.setApp_logo("http://pic36.nipic.com/20131128/11748057_141932278338_2.jpg");
            appInfo.setApp_name("测试应用");
            appInfoList.add(appInfo);
            //demo 测试 end*/
            //请求网络数据 刷新数据
            new AppInfoDataManager(mLauncher, 0, foldid).requestAppInfoList(new AppInfoDataManager.AppInfoCallback() {
                @Override
                public void onSuccess(List<com.klauncher.biddingos.distribute.model.AppInfo> appList) {
                    LogUtil.e("wqh_Folder", "initAPUS onSuccess");
                    if (null == appList || appList.size() == 0) {
                        LogUtil.e("wqh_Folder", "initAPUS onSuccess 获取AppInfoList失败");
                        ll_adapks_contain.setVisibility(View.GONE);
                        view_placeholder.setVisibility(View.VISIBLE);
                    } else {
                        LogUtil.e("wqh_Folder", "initAPUS onSuccess 获取AppInfoList成功");
                        LogUtil.e("wqh_Folder","size ="+appList.size());
                        for (int i = 0; i < appList.size(); i++) {
                            Log.e("wqh_Folder", "onSuccess: " + appList.get(i).toString());
                        }
                        //添加数据 测试 RecommendBannerScreenView  RecommendAppsThumbnailView
                        //demo 测试 begin
                       /* for (int i = 0; i < 4; i++) {
                            com.klauncher.biddingos.distribute.model.AppInfo appInfo = new com.klauncher.biddingos.distribute.model.AppInfo();
                            appInfo.setApp_id("000" + i);
                            appInfo.setApp_download_url("http://wap.apk.anzhi.com/data3/apk/201509/25/59b889fe34ff222aa82ebc7ab582aeac_33177100.apk");
                            appInfo.setApp_logo("http://pic36.nipic.com/20131128/11748057_141932278338_2.jpg");
                            appInfo.setApp_name("测试应用");
                            appList.add(appInfo);
                        }*/
                        //demo 测试 end
                        appInfoList.clear();
                        appInfoList.addAll(appList);
                        setAndrefushApkItems(appInfoList);
                    }
                }

                @Override
                public void onFail() {
                    LogUtil.e("wqh_Folder", "initAPUS onFail 获取AppInfoList失败");
                    ll_adapks_contain.setVisibility(View.GONE);
                    view_placeholder.setVisibility(View.VISIBLE);

                }
            });


        } else {
            //隐藏广告
            ll_adapks_contain.setVisibility(View.GONE);
            view_placeholder.setVisibility(View.VISIBLE);
        }

    }

    private void clearCacheData(){
        appInfoList.clear();
    }

    private int mCurrentFacePage = 0;// 广告应用选择索引
    private int pageCount = 0;

    /**
     * 刷新设置
     */
    public synchronized void setAndrefushApkItems(List<com.klauncher.biddingos.distribute.model.AppInfo> appinfolist) {
        if (appinfolist == null || appinfolist.size() < 1) {
            return;
        }
        //删除无效项
        for (Iterator<com.klauncher.biddingos.distribute.model.AppInfo> it = appinfolist.iterator(); it.hasNext(); ) {
            com.klauncher.biddingos.distribute.model.AppInfo element = it.next();
            if (!element.isValid()) {
                it.remove();
            }
        }
        if (appinfolist == null || appinfolist.size() < 1) {
            ll_adapks_contain.setVisibility(View.GONE);
            view_placeholder.setVisibility(View.VISIBLE);
            return;
        }
        //广告数量
        int adCount = appinfolist.size();
        LogUtil.e("wqh_Folder","adCount"+adCount);
        //余数
        int  adRemainder = adCount % 3;
        int adPageCount = (adCount - adRemainder) / (int) 3;
        //缩略图view 列表
        List<View> lv = new ArrayList<View>();
        for (int i = 0; i < adPageCount; i++) {
            //缩略图列表
            lv.add(getSingleAdPage(appinfolist, i));
        }
        //单独添加 最后一页
        if(adRemainder>0){
            lv.add(getSingleAdPage(appinfolist,adPageCount));
        }
        AdApkPagerAdapter adapter = new AdApkPagerAdapter(lv);
        vp_adapk_pager.setAdapter(adapter);
        vp_adapk_pager.setCurrentItem(mCurrentFacePage);
        //分发广告页数
        pageCount = lv.size();
        CirclePageIndicator indicator = (CirclePageIndicator) findViewById(R.id.adapk_indicator);
        indicator.setViewPager(vp_adapk_pager);
        adapter.notifyDataSetChanged();
        indicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

            }

            @Override
            public void onPageSelected(int position) {
                mCurrentFacePage = position;
            }

            @Override
            public void onPageScrollStateChanged(int state) {

            }
        });
        ll_adapks_contain.setVisibility(View.VISIBLE);
        relativeAdApkTop.setVisibility(View.VISIBLE);
        vp_adapk_pager.setVisibility(View.VISIBLE);
        view_placeholder.setVisibility(View.GONE);
        //点击打开初始化
        //打开条幅列表
        initAPUSBanner(appinfolist);
    }

    private View getSingleAdPage(List<com.klauncher.biddingos.distribute.model.AppInfo> appinfolist, int page) {
        //整页显示  一页不完整显示分别处理
        View view = mInflater.inflate(R.layout.include_adapk_contain, this, false);
        ImageView[] adApkImages = new ImageView[3];
        adApkImages[0] = (ImageView) view.findViewById(R.id.iv_adapk1);
        adApkImages[1] = (ImageView) view.findViewById(R.id.iv_adapk2);
        adApkImages[2] = (ImageView) view.findViewById(R.id.iv_adapk3);
        TextView[] adApkTexts = new TextView[3];
        adApkTexts[0] = (TextView) view.findViewById(R.id.tv_adapk1);
        adApkTexts[1] = (TextView) view.findViewById(R.id.tv_adapk2);
        adApkTexts[2] = (TextView) view.findViewById(R.id.tv_adapk3);
        LinearLayout[] adApkLinears = new LinearLayout[3];
        adApkLinears[0] = (LinearLayout) view.findViewById(R.id.ll_adapk1);
        adApkLinears[1] = (LinearLayout) view.findViewById(R.id.ll_adapk2);
        adApkLinears[2] = (LinearLayout) view.findViewById(R.id.ll_adapk3);
        //计算底部长度
        //先初始化 invisible
        for (int i = 0; i < 3; i++) {
            adApkLinears[i].setVisibility(View.VISIBLE);
        }

        //设置数据
        int adSize = appinfolist.size();
        int setFlag = -1;
        for (int i = page * 3; i <= Math.min(page * 3 + 2,adSize-1); i++) {
            final com.klauncher.biddingos.distribute.model.AppInfo appInfo = appinfolist.get(i);
            LogUtil.e("getSingleAdPage", appInfo.toString());
            setFlag = setFlag +1;
            //0-2 3-5 6-8
            final ImageView imageView = adApkImages[i % 3];
            final TextView textview = adApkTexts[i % 3];
            final LinearLayout linear = adApkLinears[i % 3];
            linear.setVisibility(View.VISIBLE);
            Target target = new Target() {
                @Override
                public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {
                    imageView.setImageBitmap(bitmap);
                }

                @Override
                public void onBitmapFailed(Drawable errorDrawable) {
                }

                @Override
                public void onPrepareLoad(Drawable placeHolderDrawable) {
                }
            };
            imageView.setTag(target);
            int iconSize = LauncherAppState.getInstance().getDynamicGrid().getDeviceProfile().iconSizePx;
            Picasso.with(mLauncher)
                    .load(appInfo.getApp_logo())
                    .resize((int) (0.8 * iconSize), (int) (0.8 * iconSize)).centerCrop().into(imageView);//networkPolicy(NetworkPolicy.OFFLINE).

            imageView.setLayoutParams(new LayoutParams(iconSize, iconSize));
            textview.setText(appInfo.getApp_name());
            imageView.setTag(R.id.tag_first, appInfo);
            imageView.setTag(R.id.tag_second, new Integer(i));
            textview.setTag(R.id.tag_first, appInfo);
            textview.setTag(R.id.tag_second, new Integer(i));
            linear.setTag(R.id.tag_first, appInfo);
            linear.setTag(R.id.tag_second, new Integer(i));
            //显示上报
            new AdHelplerImpl().notifyImpression(currentFoldId, appInfo.getApp_id());
            //埋点展示上报

            View.OnClickListener adApkListener = new OnClickListener() {
                @Override
                public void onClick(View v) {
                    com.klauncher.biddingos.distribute.model.AppInfo appInfo =
                            (com.klauncher.biddingos.distribute.model.AppInfo) v.getTag(R.id.tag_first);
                    int index = (Integer) v.getTag(R.id.tag_second);
                    if (appInfo != null && index > -1) {
                        if (bannerPopuWindow == null && appInfoList != null && appInfoList.size() > 0) {
                            initAPUSBanner(appInfoList);
                        } else if (bannerPopuWindow != null) {
                            //return;
                        } else {
                            return;
                        }
                        Rect rect = new Rect();
                        getHitRect(rect);
                        //计算 X Y 坐标
                        WindowManager wm = (WindowManager) mLauncher.getSystemService(Context.WINDOW_SERVICE);
                        int screenHeight = wm.getDefaultDisplay().getHeight();
                        int screenWidth = wm.getDefaultDisplay().getWidth();
                        int x = (screenWidth - popupWindowWidth) / 2;
                        int y = (screenHeight - popupWindowHeight) / 2;
                        int xoff = (screenWidth - popupWindowWidth)/2 - (getLeft()+mFolderTitleSection.getLeft());
                        bannerPopuWindow.showAsDropDown(mFolderTitleSection, xoff, 0);
                        bannerPager.setCurrentItem(index);
                    }
                }
            };
            linear.setOnClickListener(adApkListener);
            textview.setOnClickListener(adApkListener);
        }
        if(setFlag<2){
            //从 下一项开始隐藏
            int iconSize = (int) (0.8 * LauncherAppState.getInstance().getDynamicGrid().getDeviceProfile().iconSizePx);
            for(int i = setFlag+1;i<=2;i++){
                LinearLayout.LayoutParams layoutParams = (LayoutParams) adApkImages[i].getLayoutParams();
                layoutParams.width = iconSize;
                layoutParams.height = iconSize;
                adApkImages[i].setLayoutParams(layoutParams);
                adApkLinears[i].setVisibility(View.INVISIBLE);
            }
        }

        return view;

    }

    public PopupWindow bannerPopuWindow;//banner windoow 框
    private int popupWindowWidth, popupWindowHeight;
    private View bannerView;//banner view
    private ViewPager bannerPager;//banner viewpager
    private List<View> bannerItemList;//banner itme list

    //初始化 banner item
    private void initAPUSBanner(List<com.klauncher.biddingos.distribute.model.AppInfo> appinfolist) {
        bannerView = mInflater.inflate(R.layout.recommend_banner_view, this, false);
        bannerPager = (ViewPager) bannerView.findViewById(R.id.vp_adapk_banner_pager);
        bannerItemList = new ArrayList<View>();
        //for (int i = 0; i < 3 * pageCount; i++) {
        for (int i = 0; i <  appinfolist.size(); i++) {
            final com.klauncher.biddingos.distribute.model.AppInfo appInfo = appinfolist.get(i);
            View itemView = mInflater.inflate(R.layout.item_recommend_banner, this, false);
            final ImageView ivBannerIcon = (ImageView) itemView.findViewById(R.id.iv_adapkbanner_icon);
            Target target = new Target() {
                @Override
                public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) {
                    ivBannerIcon.setImageBitmap(bitmap);
                }

                @Override
                public void onBitmapFailed(Drawable errorDrawable) {
                }

                @Override
                public void onPrepareLoad(Drawable placeHolderDrawable) {
                }
            };
            ivBannerIcon.setTag(target);
            int iconSize = LauncherAppState.getInstance().getDynamicGrid().getDeviceProfile().iconSizePx;
            Picasso.with(mLauncher).load(appInfo.getApp_logo()).resize((int) (1.2 * iconSize), (int) (1.2 * iconSize)).centerCrop().into(ivBannerIcon);//.networkPolicy(NetworkPolicy.OFFLINE)

            TextView tvBannerName = (TextView) itemView.findViewById(R.id.tv_adapkbanner_name);
            tvBannerName.setText(appInfo.getApp_name());
            TextView tvBannerDec = (TextView) itemView.findViewById(R.id.tv_adapk_desc);
            //截取 软件介绍 后面字符
            String strDesc = getAppDesc(appInfo.getApp_desc());
            /*int index = -1;
            if(strDesc.contains("软件介绍：")){
                index = Math.min(strDesc.indexOf("软件介绍：")+5,strDesc.length()-1);
            }else{
                index = 0;
            }*/
            tvBannerDec.setText(strDesc);
            TextView tvType = (TextView) itemView.findViewById(R.id.tv_adapk_type);
            tvType.setText(appInfo.getMaincategory() + "  |  " + bytes2kb(appInfo.getApp_size()));
            Button btnInstall = (Button) itemView.findViewById(R.id.btn_adapk_installed);
            btnInstall.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    //点击下载 统计
                    if (appInfo != null) {
                        appInfo.downloadAPK();
                        //点击上报
                        new AdHelplerImpl().notifyClick(currentFoldId, appInfo.getApp_id());
                        //埋点上报统计
                        HashMap<String,String> reportMap = new HashMap<String, String>();
                        reportMap.put("pxt_app_id",appInfo.getApp_id());
                        reportMap.put("pxt_app_name",appInfo.getApp_name());
                        reportMap.put("pxt_app_pkgname",appInfo.getPackageName());
                        reportMap.put("pxt_app_price",appInfo.getApp_price()+"");
                        PingManager.getInstance().reportUserActionMap4App(PingManager.KLAUNCHER_PINXIAOTONG_DOWNLOAD,
                                mLauncher.getPackageName(),reportMap);
                        LogUtil.d("reportUserActionMap4App","点击下载上报成功");
                        //隐藏详情页面
                        bannerPopuWindow.dismiss();
                    }
                }
            });
            bannerItemList.add(itemView);
        }
        //viewpager
        AdApkPagerAdapter adapter = new AdApkPagerAdapter(bannerItemList);
        bannerPager.setAdapter(adapter);
        //popupWindow
        //popupWindowWidth = dip2px(mLauncher, 300);
        popupWindowWidth = getBannerWidth();
        //popupWindowWidth = relativeAdApkTop.getWidth()-relativeAdApkTop.getPaddingLeft() -relativeAdApkTop.getPaddingRight() ;
        popupWindowHeight =dip2px(mLauncher, 330);
        bannerPopuWindow = new PopupWindow(bannerView,
                popupWindowWidth, popupWindowHeight, true);

        bannerPopuWindow.setTouchable(true);

        bannerPopuWindow.setTouchInterceptor(new OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {

                Log.i("mengdd", "onTouch : ");

                return false;
                // 这里如果返回true的话，touch事件将被拦截
                // 拦截后 PopupWindow的onTouchEvent不被调用，这样点击外部区域无法dismiss
            }
        });

        // 如果不设置PopupWindow的背景，无论是点击外部区域还是Back键都无法dismiss弹框
        // 我觉得这里是API的一个bug
        bannerPopuWindow.setBackgroundDrawable(getResources().getDrawable(
                R.drawable.thumbnail_item_bg_dark));

        // 设置好参数之后再show
        //bannerPopuWindow.showAtLocation(mScrollView, Gravity.CENTER,0,0);
        //bannerPopuWindow.showAsDropDown(mScrollView);
    }
    /**
     *软件介绍简介截取
     */
    private String getAppDesc(String strdesc){
        LogUtil.d("getAppDesc",strdesc);
        String strDesc = "";
        if(strdesc != null && strdesc.trim().length()>0 ){
            Pattern p = Pattern.compile("\\s*|\t|\r|\n");
            Matcher m = p.matcher(strdesc);
            strDesc = m.replaceAll("");
            //strDesc = strdesc.trim().replace(" ","");
        }
        LogUtil.d("getAppDesc",strDesc);
        return strDesc;
    }

    /**
     * dp2px
     */
    public int dip2px(Context context, float dpValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (dpValue * scale + 0.5f);
    }
    /*加号 跳转软件管家 功能 begin*/

    /**
     * byte(字节)根据长度转成kb(千字节)和mb(兆字节)
     *
     * @param bytes
     * @return
     */
    public static String bytes2kb(long bytes) {
        BigDecimal filesize = new BigDecimal(bytes);
        BigDecimal megabyte = new BigDecimal(1024 * 1024);
        float returnValue = filesize.divide(megabyte, 2, BigDecimal.ROUND_UP)
                .floatValue();
        if (returnValue > 1)
            return (returnValue + "MB");
        BigDecimal kilobyte = new BigDecimal(1024);
        returnValue = filesize.divide(kilobyte, 2, BigDecimal.ROUND_UP)
                .floatValue();
        return (returnValue + "KB");
    }

}
